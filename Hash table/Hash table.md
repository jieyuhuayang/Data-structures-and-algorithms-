# Hash table（散列表）  
## 1. what is Hash table   
给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址。  
则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。
  
## 2. hash function  
实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：    
- 计算哈希函数所需时间  
- 关键字的长度
- 哈希表的大小
- 关键字的分布情况
- 记录的查找频率     

2.1 直接寻址法：  
    取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。  
    
2.2 数字分析法：  
分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。  

2.3 平方取中法：  
当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：**平方后中间几位和关键字中每一位都相关**，故不同关键字会以较高的概率产生不同的哈希地址。  

2.4 折叠法：  
将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。  
数位叠加可以有**移位叠加**和**间界叠加**两种方法。  
移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。  
  
2.5 随机数法：  
选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。  
  
2.6 除留余数法：  
取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。  

2.7斐波那契（Fibonacci）散列法   
平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。  
- 对于16位整数而言，这个乘数是40503   
- 对于32位整数而言，这个乘数是2654435769   
- 对于64位整数而言，这个乘数是11400714819323198485   

## 3. hash collisions and solutions  
### 3.1  hash collisions:   
The hash function generates the same index for more than one key  
### 3.2 Collision resolution:  
#### 3.2.1 开散列方法 之 Separate chaining(分离链接法)   
将散列到同一个值的所有元素保留到一个链表中，无需预留任何更多的空间，只要系统的资源足够，任意多次的冲突都可以解决。  
装载因子一般大于1
缺点：
- 节点需要动态申请，开销比正常高2个数量级
- 动态分配的空间未必在物理上连续分布，系统缓存几乎失效  
  
#### 3.2.2 Open addressing(开放寻址法) / closed hashing(闭散列)   
无需向分离链接那样申请额外的空间，散列表所占用的空间在物理上始终是地址连续的一块，相应的所有的冲突都在这块连续空间中解决。  
开放寻址法的装载因子不超过0.5。  
如果有冲突发生，从这个单元往后，都按照某种优先级规则排成一个序列，而在查找的时候也是按着这个序列行进，每个词条对应的这个序列被称为探测序列or查找链。  
3.2.2.1 开放定址法——线性探测(Linear Probing)：  
在线性探测法中，函数F是关于i的线性函数，典型的情形是F(i)=i。  
当遇到冲突时，每次从i=0开始尝试，根据hi(x)= ( Hash(x) + F(I) ) % TableSize就可以计算出各自不相冲突的地址了。    
事实上 linear probing 相当于逐个探测每个单元（必要时可以绕回）以查找出一个空单元。在物理上也具有了局部性。   
缺点：冲突增加；删除操作复杂（解决办法：lazy delete，仅做一个删除标记，比如里面预留一个del变量，设置为TRUE）  

3.2.2.2 更优化的方案： 开放定址法——平方探测(Quadratic Probing)   
冲突函数F(i)是二次函数的探测方法。通常会选择f(i)=i^2。   
